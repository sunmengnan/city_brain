# 00-graph-algorithms 


#  给定起点和终点，计算最短路径 -- dijkstra、flord、A*的算法
给定加权图，权重即路或link的距离，找到从起点到终点的最短路径<Br/>
0. 当存在还需要处理的点<Br/>
1. 找出最短的节点<Br/>
2. 更新该节点到相邻点的开销<Br/>
3. 如果开销被更新，同时更新父节点<Br/>
4. 重复这个过程，直到图中的每个点都更新<Br/>
5. 计算最终路径<Br/>
实现时需要三个散列表，graph，distance和parents，分别记录图，图的开销更新和图的路径更新<Br/>

# 给定n个点，计算经过所有点的最短路径 -- bfs, dp, greedy,遗传算法,线性规划等
如果要找出经由指定几个点的最短路径，属于np问题，因<Br/>
0. 点较少时运行速度非常快，但随着点的增加，速度变得非常慢<Br/>
1. 涉及到所有路径的序列，需要遍历所有组合<Br/>
路径的个数为点个数的阶乘函数，对于np问题当点的数量比较小时，可以用bfs或dp，<Br/>
当点比较多时，可以用greedy近似求解，随机选择起点，然后每次选择下一个点都选择最近的点

